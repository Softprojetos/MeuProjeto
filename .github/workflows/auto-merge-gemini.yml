name: Auto-merge after Gemini Review

on:
  issue_comment:
    types: [created]

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    if: |
      github.event.comment.user.login == 'gemini-code-assist[bot]' &&
      contains(github.event.comment.body, 'Summary of Changes')
    steps:
      - name: Wait for full review
        run: sleep 90

      - name: Check review and decide
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            if (!issue || !issue.pull_request) {
              console.log('Not a PR comment, skipping');
              return;
            }
            
            const prNumber = issue.number;
            console.log(`Processing PR #${prNumber}`);
            
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });
            
            const { data: reviewComments } = await github.rest.pulls.listReviewComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            const geminiReviewComments = reviewComments.filter(c =>
              c.user.login === 'gemini-code-assist[bot]'
            );
            
            const allText = comments.filter(c => c.user.login === 'gemini-code-assist[bot]')
              .map(c => c.body).join(' ').toLowerCase();
            const reviewText = geminiReviewComments.map(c => c.body).join(' ').toLowerCase();
            const fullText = allText + ' ' + reviewText;
            
            const blockingKeywords = [
              'bug', 'critical', 'security', 'vulnerability', 'injection',
              'sql injection', 'xss', 'credential', 'password exposed',
              'hardcoded secret', 'data leak', 'race condition'
            ];
            
            const hasBlockingIssues = blockingKeywords.some(kw => fullText.includes(kw)) 
              && geminiReviewComments.length > 0;
            
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            if (pr.state !== 'open') return;

            if (hasBlockingIssues) {
              console.log(`PR #${prNumber} has blocking issues, NOT merging`);
              const issuesList = geminiReviewComments
                .map(c => `- ${c.body.substring(0, 150)}...`)
                .join('\n');
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `‚ö†Ô∏è **Auto-merge bloqueado**\n\nO Gemini encontrou ${geminiReviewComments.length} problema(s) no c√≥digo.\n\nüìã **Problemas:**\n${issuesList}`
              });
              return;
            }

            try {
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                merge_method: 'squash'
              });
              console.log(`PR #${prNumber} merged`);
              
              try {
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `heads/${pr.head.ref}`
                });
              } catch (e) {}
            } catch (e) {
              console.log('Could not merge:', e.message);
            }
